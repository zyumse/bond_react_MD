import numpy as np
import numpy.linalg as LA
import re
import scipy.constants as scc
import pandas as pd


def write_lammps_simple(file_name,box_new,ntypes,natoms_new,mass,element,charge,index_new,atom_type_new,coors_new):
    """
    A = (xhi-xlo,0,0); B = (xy,yhi-ylo,0); C = (xz,yz,zhi-zlo)

    shift the origin to 0 0 0
    """
    f=open('{}'.format(file_name),'w')
    f.write('Generated by python script\n\n')

    f.write('{0:5d} atoms\n'.format(natoms_new))
    f.write('{0:d} atom types\n'.format(ntypes))
    f.write('\n')

    f.write('{0:.16f} {1:.16f} xlo xhi\n'.format(0,box_new[0,0]))
    f.write('{0:.16f} {1:.16f} ylo yhi\n'.format(0,box_new[1,1]))
    f.write('{0:.16f} {1:.16f} zlo zhi\n'.format(0,box_new[2,2]))

    if box_new[0,1]!=0 or box_new[0,1]!=0 or box_new[0,1]!=0:
        f.write('{0:.16f} {1:.16f} {2:.16f} xy xz yz\n'.format(box_new[0,1],box_new[0,2],box_new[1,2]))

    f.write('\n')
    f.write('Masses\n\n')

    for i in range(len(mass)):
        f.write('{0:d} {1:.6f} # {2:s}\n'.format(i+1,mass[i],element[i])) 
    f.write('\n')
    f.write('Atoms # charge\n\n')

    for ia in range(natoms_new):
        f.write('{0:d} {1:d} {2:.4f} {3:.16f} {4:.16f} {5:.16f}\n'.format(int(index_new[ia]),int(atom_type_new[ia]),charge[int(atom_type_new[ia])-1],coors_new[ia,0],coors_new[ia,1],coors_new[ia,2]))

    f.close()

    

def write_lammps_full(file_name,lmp_tmp):
    """
    input: file_name,lmp_tmp
    lmp_tmp is a class of lammps with full attributes, 
    must contain natoms, natom_types, x, y, z, atom_info, mass, pair_coeff 
    optionally contain 
    """
    f=open('{}'.format(file_name),'w')
    f.write('Generated by ZY code\n\n')
    
    try: 
        f.write('{} atoms\n'.format(lmp_tmp.natoms))
        f.write('{} atom types\n'.format(lmp_tmp.natom_types))
        f.write('{} bonds\n'.format(lmp_tmp.nbonds))
        f.write('{} bond types\n'.format(lmp_tmp.nbond_types))
        f.write('{} angles\n'.format(lmp_tmp.nangles))
        f.write('{} angle types\n'.format(lmp_tmp.nangle_types))
        f.write('{} dihedrals\n'.format(lmp_tmp.ndihedrals))
        f.write('{} dihedral types\n'.format(lmp_tmp.ndihedral_types))
        f.write('{} impropers\n'.format(lmp_tmp.nimpropers))
        f.write('{} improper types\n'.format(lmp_tmp.nimproper_types))
        f.write('\n')

    
        f.write('{0:.16f} {1:.16f} xlo xhi\n'.format(lmp_tmp.x[0],lmp_tmp.x[1]))
        f.write('{0:.16f} {1:.16f} ylo yhi\n'.format(lmp_tmp.y[0],lmp_tmp.y[1]))
        f.write('{0:.16f} {1:.16f} zlo zhi\n'.format(lmp_tmp.z[0],lmp_tmp.z[1]))
        f.write('\n')
        
        f.write('Masses\n\n')
        for i in range(len(lmp_tmp.mass)):
            if lmp_tmp.mass.shape[1]==3:
                f.write('{0:d} {1:.3f} # {2:s}\n'.format(int(float(lmp_tmp.mass[i,0])),float(lmp_tmp.mass[i,1]),lmp_tmp.mass[i,2]))
            elif lmp_tmp.mass.shape[1]==2:
                f.write('{0:d} {1:.3f}\n'.format(int(float(lmp_tmp.mass[i,0])),float(lmp_tmp.mass[i,1])))
        f.write('\n')
        
        if hasattr(lmp_tmp,'pair_coeff') and not(lmp_tmp.pair_coeff is None):
            f.write('Pair Coeffs\n\n')
            for i in range(len(lmp_tmp.pair_coeff)):
                f.write('{0:d} {1:f} {2:f}\n'.format(int(lmp_tmp.pair_coeff[i,0]),lmp_tmp.pair_coeff[i,1],lmp_tmp.pair_coeff[i,2]))
            f.write('\n')
        
        if hasattr(lmp_tmp,'bond_coeff') and not(lmp_tmp.bond_coeff is None):
            f.write('Bond Coeffs\n\n')
            for i in range(len(lmp_tmp.bond_coeff)):
                f.write('{0:d} {1:f} {2:f}\n'.format(int(lmp_tmp.bond_coeff[i,0]),lmp_tmp.bond_coeff[i,1],lmp_tmp.bond_coeff[i,2]))
            f.write('\n')
        
        if hasattr(lmp_tmp,'angle_coeff') and not(lmp_tmp.angle_coeff is None):
            f.write('Angle Coeffs\n\n')
            for i in range(len(lmp_tmp.angle_coeff)):
                f.write('{0:d} {1:f} {2:f}\n'.format(int(lmp_tmp.angle_coeff[i,0]),lmp_tmp.angle_coeff[i,1],lmp_tmp.angle_coeff[i,2]))
            f.write('\n')
        
        if hasattr(lmp_tmp,'dihedral_coeff') and not(lmp_tmp.dihedral_coeff is None):
            f.write('Dihedral Coeffs\n\n')
            for i in range(len(lmp_tmp.dihedral_coeff)):
                f.write('{0:d} {1:f} {2:f} {3:f} {4:f}\n'.format(int(lmp_tmp.dihedral_coeff[i,0]),lmp_tmp.dihedral_coeff[i,1],lmp_tmp.dihedral_coeff[i,2],
                                                    lmp_tmp.dihedral_coeff[i,3],lmp_tmp.dihedral_coeff[i,4]))
            f.write('\n')
        
        if hasattr(lmp_tmp,'improper_coeff') and not(lmp_tmp.improper_coeff is None):
            f.write('Improper Coeffs\n\n')
            for i in range(len(lmp_tmp.improper_coeff)):
                f.write('{0:d} {1:f} {2:d} {3:d}\n'.format(int(lmp_tmp.improper_coeff[i,0]),lmp_tmp.improper_coeff[i,1],int(lmp_tmp.improper_coeff[i,2]),
                                                    int(lmp_tmp.improper_coeff[i,3])))
            f.write('\n')
        
        f.write('Atoms # full\n\n')
        for i in range(len(lmp_tmp.atom_info)):
            if lmp_tmp.atom_info.shape[1]>7:
                f.write('{0:d} {1:d} {2:d} {3:f} {4:f} {5:f} {6:f} {8:d} {7:d} {9:d}\n'.format(int(lmp_tmp.atom_info[i,0]),int(lmp_tmp.atom_info[i,1]),int(lmp_tmp.atom_info[i,2]),
                                                        lmp_tmp.atom_info[i,3],lmp_tmp.atom_info[i,4],lmp_tmp.atom_info[i,5],lmp_tmp.atom_info[i,6],
                                int(lmp_tmp.atom_info[i,7]),int(lmp_tmp.atom_info[i,8]),int(lmp_tmp.atom_info[i,9]) ))
            else:
                f.write('{0:d} {1:d} {2:d} {3:f} {4:f} {5:f} {6:f}\n'.format(int(lmp_tmp.atom_info[i,0]),int(lmp_tmp.atom_info[i,1]),int(lmp_tmp.atom_info[i,2]),
                                                        lmp_tmp.atom_info[i,3],lmp_tmp.atom_info[i,4],lmp_tmp.atom_info[i,5],lmp_tmp.atom_info[i,6]))
        f.write('\n')
        
        if hasattr(lmp_tmp,'velocity_info') and not(lmp_tmp.velocity_info is None):
            f.write('Velocities \n\n')
            for i in range(len(lmp_tmp.velocity_info)):
                f.write('{0:d} {1:f} {2:f} {3:f}\n'.format(int(lmp_tmp.velocity_info[i,0]),lmp_tmp.velocity_info[i,1],lmp_tmp.velocity_info[i,2],lmp_tmp.velocity_info[i,3]))
            f.write('\n')
        
        if hasattr(lmp_tmp, 'bond_info') and not(lmp_tmp.bond_info is None):
            f.write('Bonds\n\n')
            for i in range(len(lmp_tmp.bond_info)):
                f.write('{0:d} {1:d} {2:d} {3:d}\n'.format(int(lmp_tmp.bond_info[i,0]),int(lmp_tmp.bond_info[i,1]),int(lmp_tmp.bond_info[i,2]),int(lmp_tmp.bond_info[i,3])))
            f.write('\n')
        
        if hasattr(lmp_tmp, 'angle_info') and not(lmp_tmp.angle_info is None):
            f.write('Angles\n\n')
            for i in range(len(lmp_tmp.angle_info)):
                f.write('{0:d} {1:d} {2:d} {3:d} {4:d}\n'.format(int(lmp_tmp.angle_info[i,0]),int(lmp_tmp.angle_info[i,1]),int(lmp_tmp.angle_info[i,2]),
                                                                int(lmp_tmp.angle_info[i,3]),int(lmp_tmp.angle_info[i,4])))
            f.write('\n')
        
        if hasattr(lmp_tmp, 'dihedral_info') and not(lmp_tmp.dihedral_info is None):
            f.write('Dihedrals\n\n')
            for i in range(len(lmp_tmp.dihedral_info)):
                f.write('{0:d} {1:d} {2:d} {3:d} {4:d} {5:d}\n'.format(int(lmp_tmp.dihedral_info[i,0]),int(lmp_tmp.dihedral_info[i,1]),int(lmp_tmp.dihedral_info[i,2]),
                                                                int(lmp_tmp.dihedral_info[i,3]),int(lmp_tmp.dihedral_info[i,4]),int(lmp_tmp.dihedral_info[i,5])))
            f.write('\n')
        
        if hasattr(lmp_tmp, 'improper_info') and not(lmp_tmp.improper_info is None):
            f.write('Impropers\n\n')
            for i in range(len(lmp_tmp.improper_info)):
                f.write('{0:d} {1:d} {2:d} {3:d} {4:d} {5:d}\n'.format(int(lmp_tmp.improper_info[i,0]),int(lmp_tmp.improper_info[i,1]),int(lmp_tmp.improper_info[i,2]),
                                                                int(lmp_tmp.improper_info[i,3]),int(lmp_tmp.improper_info[i,4]),int(lmp_tmp.improper_info[i,5])))
            f.write('\n')

    except AttributeError:
        print('error')
    
    f.close()

class lammps:
    def __init__(self, natoms, natom_types, x, y, z, mass, atom_info, nbonds=0, nangles=0, ndihedrals=0, nimpropers=0,
                nbond_types=0, nangle_types=0, ndihedral_types=0, nimproper_types=0,
                pair_coeff=None, bond_coeff=None, angle_coeff=None, dihedral_coeff=None, improper_coeff=None,
                velocity_info=None, bond_info=None, angle_info=None, dihedral_info=None, improper_info=None):
        self.natoms = natoms
        self.nbonds = nbonds
        self.nangles = nangles
        self.ndihedrals = ndihedrals
        self.nimpropers = nimpropers

        self.natom_types = natom_types
        self.nbond_types = nbond_types
        self.nangle_types = nangle_types
        self.ndihedral_types = ndihedral_types
        self.nimproper_types = nimproper_types

        self.x = x
        self.y = y
        self.z = z

        self.mass = mass
        self.pair_coeff = pair_coeff
        self.bond_coeff = bond_coeff
        self.angle_coeff = angle_coeff
        self.dihedral_coeff = dihedral_coeff
        self.improper_coeff = improper_coeff

        self.atom_info = atom_info
        self.velocity_info = velocity_info
        self.bond_info = bond_info
        self.angle_info = angle_info
        self.dihedral_info = dihedral_info
        self.improper_info = improper_info


# this is not related to lammps, maybe put to another file for general purpose 
def distance_pbc(coord1, coord2, box): 
    """
    Calculate the distance between two atoms in a box with periodic boundary conditions.
    inputs: coord1, coord2, box
    output: dist_matrix
    """

    delta = coord1 - coord2
    delta -= np.round(delta @ np.linalg.inv(box)) @ box
    dist_matrix = np.linalg.norm(delta, axis=-1)
    return dist_matrix

def read_lammps_dump_custom(dump_file):
    """
    input: dump_file
    output: frame, t_list, L_list
    """
    t_list = []
    frame = []
    L_list = []
    with open(dump_file, 'r') as f:
        for line in f:
            if line.startswith('ITEM: TIMESTEP'):
                # if int(next(f).split()[0]) == 900000:
                t_list.append(int(next(f).split()[0]))
            if line.startswith('ITEM: NUMBER OF ATOMS'):
                natoms = int(next(f).split()[0])
            if line.startswith('ITEM: BOX'):
                lx = [float(x) for x in next(f).split()[:2]]
                ly = [float(x) for x in next(f).split()[:2]]
                lz = [float(x) for x in next(f).split()[:2]]
                L_list.append([lx,ly,lz])
            if line.startswith('ITEM: ATOMS'):
                columns = line.split()[2:]
                data = []
                for i in range(natoms):
                    data.append([float(x) for x in next(f).split()])
                df = pd.DataFrame(data, columns=columns)
                df_sorted = df.sort_values(by=['id'])
                frame.append(df_sorted)

    return frame, t_list, L_list


def read_lammps_full(file):

    f=open(file,'r')
    L=f.readlines()
    f.close()

    isxyxzyz = 0
    for iline in range(len(L)):
        if 'atoms' in L[iline]:
            natoms = int(L[iline].split()[0])

        if 'atom types' in L[iline]:
            natom_types = int(L[iline].split()[0])

        if 'xlo' in L[iline]:
            xlo=float(L[iline].split()[0])
            xhi=float(L[iline].split()[1])
        if 'ylo' in L[iline]:
            ylo=float(L[iline].split()[0])
            yhi=float(L[iline].split()[1])
        if 'zlo' in L[iline]:
            zlo=float(L[iline].split()[0])
            zhi=float(L[iline].split()[1])
        if 'Masses' in L[iline]:
            lmass = iline+2
            mass = []
            for ia in range(natom_types):
                mass.append(L[lmass+ia].split())
            mass = np.vstack(mass)
        if 'Atoms' in L[iline]:
            lia = iline+2
            atom_info = []
            for ia in range(natoms):
                atom_info.append(L[lia+ia].split())
            atom_info = np.vstack(atom_info).astype(float)

    result = lammps(natoms, natom_types, [xlo,xhi], [ylo,yhi], [zlo,zhi], mass, atom_info)

    for iline in range(len(L)):
        if 'bonds' in L[iline]:
            result.nbonds = int(L[iline].split()[0])
        if 'angles' in L[iline]:
            result.nangles = int(L[iline].split()[0])
        if 'dihedrals' in L[iline]:
            result.ndihedrals = int(L[iline].split()[0])
        if 'impropers' in L[iline]:
            result.nimpropers = int(L[iline].split()[0])
        
        if 'bond types' in L[iline]:
            result.nbond_types = int(L[iline].split()[0])
        if 'angle types' in L[iline]:
            result.nangle_types = int(L[iline].split()[0])
        if 'dihedral types' in L[iline]:
            result.ndihedral_types = int(L[iline].split()[0])
        if 'improper types' in L[iline]:
            result.nimproper_types = int(L[iline].split()[0])

        if 'xy' in L[iline]:
            isxyxzyz=1
            result.xy=float(L[iline].split()[0])
            result.xz=float(L[iline].split()[1])
            result.yz=float(L[iline].split()[2])

        ############ potential coeff ############## 
        if 'Pair Coeffs' in L[iline]:
            lpc = iline+2
            pc = []
            for ia in range(natom_types):
                pc.append(L[lpc+ia].split())
            result.pair_coeff = np.vstack(pc).astype(float)

        if 'Bond Coeffs' in L[iline]:
            lbc = iline+2
            bc = []
            for ia in range(result.nbond_types):
                bc.append(L[lbc+ia].split())
            result.bond_coeff = np.vstack(bc).astype(float)

        if 'Angle Coeffs' in L[iline]:
            lac = iline+2
            ac = []
            for ia in range(result.nangle_types):
                ac.append(L[lac+ia].split())
            result.angle_coeff = np.vstack(ac).astype(float)

        if 'Dihedral Coeffs' in L[iline]:
            ldc = iline+2
            dc = []
            for ia in range(result.ndihedral_types):
                dc.append(L[ldc+ia].split())
            result.dihedral_coeff = np.vstack(dc).astype(float)

        if 'Improper Coeffs' in L[iline]:
            lic = iline+2
            ic = []
            for ia in range(result.nimproper_types):
                ic.append(L[lic+ia].split())
            result.improper_coeff = np.vstack(ic).astype(float)


        ########### atoms ################
        
            
        if 'Velocities' in L[iline]:
            liv = iline+2
            velocity_info = []
            for ia in range(natoms):
                velocity_info.append(L[liv+ia].split())
            result.velocity_info = np.vstack(velocity_info).astype(float)

    #     ########## topology ##############
        if 'Bonds' in L[iline]:
            lib = iline+2
            bond_info = []
            for ia in range(result.nbonds):
                bond_info.append(L[lib+ia].split())
            result.bond_info = np.vstack(bond_info).astype(float)

        if 'Angles' in L[iline]:
            lian = iline+2
            angle_info = []
            for ia in range(result.nangles):
                angle_info.append(L[lian+ia].split())
            result.angle_info = np.vstack(angle_info).astype(float)

        if 'Dihedrals' in L[iline]:
            lidi = iline+2
            dihedral_info = []
            for ia in range(result.ndihedrals):
                dihedral_info.append(L[lidi+ia].split())
            result.dihedral_info = np.vstack(dihedral_info).astype(float)

        if 'Impropers' in L[iline]:
            liim = iline+2
            impropers_info = []
            for ia in range(result.nimpropers):
                impropers_info.append(L[liim+ia].split())
            result.improper_info = np.vstack(impropers_info).astype(float)

    if isxyxzyz==0:
        xy=0; xz=0; yz=0
        box = np.array([[xhi-xlo,0,0],[xy,yhi-ylo,0],[xz,yz,zhi-zlo]])
        shift = xlo 

    return result

def read_lammps_dump_xyz(dump_file):
    """
    input: dump_file
    output: frame, t_list, L_list
    """
    t_list = []
    frame = []
    with open(dump_file, 'r') as f:
        natoms = int(f.readline())
        for line in f:
            if line.startswith(' Atoms'):
                # if int(next(f).split()[0]) == 900000:
                t_list.append(line.split()[-1])
                data = []
                for i in range(natoms):
                    data.append([float(x) for x in next(f).split()])
                df = pd.DataFrame(data,columns=['type','x','y','z'])
                frame.append(df)
    return frame, t_list

def compute_mappings(file_lmp,file_key):

    
    lmp = read_lammps_full(file_lmp)
    tmp = pd.read_table(file_key,
                header=None,sep='\s+',skiprows=31,nrows=lmp.natoms)

    mapping = np.zeros([lmp.natoms,2])
    mapping[:,0] = np.arange(lmp.natoms)+1
    # modify the types given by Ligpargen
    unique_type = np.unique(tmp.iloc[:,3])
    for i, type in enumerate(unique_type):
        mapping[tmp.iloc[:,3]==type,1] = i+1

    mass_new = lmp.mass.copy()
    mass_new[:,0]=mapping[:,1]
    mass_new = np.unique(mass_new,axis=0)

    mass_to_element = {
    '1.008': 'H',
    '12.011': 'C',
    '14.007': 'N',
    '15.999': 'O',
    }

    # Function to get element name from mass
    def get_element_name(mass):
        rounded_mass = f"{float(mass):.3f}"
        return mass_to_element.get(rounded_mass, "Unknown")
    element_names = np.array([get_element_name(mass) for mass in mass_new[:, 1]])
    mass_new = np.column_stack((mass_new, element_names))

    pair_coeff_new = lmp.pair_coeff.copy()
    pair_coeff_new[:,0]=mapping[:,1]
    pair_coeff_new = np.unique(pair_coeff_new,axis=0)

    atom_info_new = lmp.atom_info.copy()
    atom_info_new[:,2]=mapping[:,1]

    ### bonds ####
    bond_info_new = lmp.bond_info.copy()
    for i in range(lmp.natoms):
        bond_info_new[lmp.bond_info[:,2]==i+1,2]=mapping[i,1]
        bond_info_new[lmp.bond_info[:,3]==i+1,3]=mapping[i,1]

    for i in range(len(bond_info_new)):
        if bond_info_new[i,2]>bond_info_new[i,3]:
            tmp = bond_info_new[i,3]
            bond_info_new[i,3] = bond_info_new[i,2]
            bond_info_new[i,2] = tmp
        
    nbond_types_new = len(np.unique(bond_info_new[:,2:],axis=0))

    mapping_bonds = np.unique(bond_info_new[:,2:],axis=0)
    # print(nbond_types_new,mapping_bonds)

    for i in range(nbond_types_new):
        idx_tmp = np.argwhere((bond_info_new[:,2]==mapping_bonds[i,0]) & (bond_info_new[:,3]==mapping_bonds[i,1]))
        bond_info_new[idx_tmp,1]=i+1

    bond_info_new[:,2:] = lmp.bond_info[:,2:]
        
    bond_coeff_new = lmp.bond_coeff.copy()
    bond_coeff_new[:,0] = bond_info_new[:,1]
    bond_coeff_new = np.unique(bond_coeff_new,axis=0)

    ### angles ####
    angle_info_new = lmp.angle_info.copy()
    for i in range(lmp.natoms):
        angle_info_new[lmp.angle_info[:,2]==i+1,2]=mapping[i,1]
        angle_info_new[lmp.angle_info[:,3]==i+1,3]=mapping[i,1]
        angle_info_new[lmp.angle_info[:,4]==i+1,4]=mapping[i,1]

    for i in range(len(angle_info_new)):
        if angle_info_new[i,2]>angle_info_new[i,4]:
            tmp = angle_info_new[i,4]
            angle_info_new[i,4] = angle_info_new[i,2]
            angle_info_new[i,2] = tmp
        
    nangle_types_new = len(np.unique(angle_info_new[:,2:],axis=0))

    mapping_angles = np.unique(angle_info_new[:,2:],axis=0)
    # print('new angles', nangle_types_new, mapping_angles)

    for i in range(nangle_types_new):
        idx_tmp = np.argwhere((angle_info_new[:,2]==mapping_angles[i,0]) & (angle_info_new[:,3]==mapping_angles[i,1]) \
                            & (angle_info_new[:,4]==mapping_angles[i,2]))
        angle_info_new[idx_tmp,1]=i+1

    angle_info_new[:,2:] = lmp.angle_info[:,2:]
        
    angle_coeff_new = lmp.angle_coeff.copy()
    angle_coeff_new[:,0] = angle_info_new[:,1]
    angle_coeff_new = np.unique(angle_coeff_new,axis=0)

    ### Dihedrals ####
    dihedral_info_new = lmp.dihedral_info.copy()
    for i in range(lmp.natoms):
        dihedral_info_new[lmp.dihedral_info[:,2]==i+1,2]=mapping[i,1]
        dihedral_info_new[lmp.dihedral_info[:,3]==i+1,3]=mapping[i,1]
        dihedral_info_new[lmp.dihedral_info[:,4]==i+1,4]=mapping[i,1]
        dihedral_info_new[lmp.dihedral_info[:,5]==i+1,5]=mapping[i,1]
        
    for i in range(len(dihedral_info_new)):
        if dihedral_info_new[i,2]>dihedral_info_new[i,5]:
            tmp1 = dihedral_info_new[i,5]
            tmp2 = dihedral_info_new[i,4]
            dihedral_info_new[i,5] = dihedral_info_new[i,2]
            dihedral_info_new[i,4] = dihedral_info_new[i,3]
            dihedral_info_new[i,2] = tmp1
            dihedral_info_new[i,3] = tmp2
        
    ndihedral_types_new = len(np.unique(dihedral_info_new[:,2:],axis=0))
    mapping_dihedrals = np.unique(dihedral_info_new[:,2:],axis=0)
    # print('dihedrals',mapping_dihedrals)

    for i in range(ndihedral_types_new):
        idx_tmp = np.argwhere((dihedral_info_new[:,2]==mapping_dihedrals[i,0]) & (dihedral_info_new[:,3]==mapping_dihedrals[i,1]) \
                            & (dihedral_info_new[:,4]==mapping_dihedrals[i,2]) & (dihedral_info_new[:,5]==mapping_dihedrals[i,3]))
        dihedral_info_new[idx_tmp,1]=i+1

    dihedral_info_new[:,2:] = lmp.dihedral_info[:,2:]

    dihedral_coeff_new = lmp.dihedral_coeff.copy()
    dihedral_coeff_new[:,0] = dihedral_info_new[:,1]
    dihedral_coeff_new = np.unique(dihedral_coeff_new,axis=0)

    ### impropers ####
    impropers_info_new = lmp.improper_info.copy()
    for i in range(lmp.natoms):
        impropers_info_new[lmp.improper_info[:,2]==i+1,2]=mapping[i,1]
        impropers_info_new[lmp.improper_info[:,3]==i+1,3]=mapping[i,1]
        impropers_info_new[lmp.improper_info[:,4]==i+1,4]=mapping[i,1]
        impropers_info_new[lmp.improper_info[:,5]==i+1,5]=mapping[i,1]

    for i in range(len(dihedral_info_new)):
        impropers_info_new[:,3:] = np.sort(impropers_info_new[:,3:])
        
    nimproper_types_new = len(np.unique(impropers_info_new[:,2:],axis=0))

    mapping_impropers = np.unique(impropers_info_new[:,2:],axis=0)
    # print('improper',nimproper_types_new,mapping_impropers)

    for i in range(nimproper_types_new):
        idx_tmp = np.argwhere((impropers_info_new[:,2]==mapping_impropers[i,0]) & (impropers_info_new[:,3]==mapping_impropers[i,1]) \
                            & (impropers_info_new[:,4]==mapping_impropers[i,2]) & (impropers_info_new[:,5]==mapping_impropers[i,3]))
        impropers_info_new[idx_tmp,1]=i+1

    impropers_info_new[:,2:] = lmp.improper_info[:,2:]
        
    improper_coeff_new = lmp.improper_coeff.copy()
    improper_coeff_new[:,0] = impropers_info_new[:,1]
    improper_coeff_new = np.unique(improper_coeff_new,axis=0)

    lmp_new = lammps(natoms=lmp.natoms,
                        natom_types=len(mass_new),
                        nbonds=lmp.nbonds,
                        nbond_types=nbond_types_new,
                        nangles=lmp.nangles,
                        nangle_types=nangle_types_new,
                        ndihedrals=lmp.ndihedrals,
                        ndihedral_types=ndihedral_types_new,
                        nimpropers=lmp.nimpropers,
                        nimproper_types=nimproper_types_new,
                        mass=mass_new,
                        x=lmp.x,
                        y=lmp.y,
                        z=lmp.z,
                        pair_coeff=pair_coeff_new,
                        bond_coeff=bond_coeff_new,
                        angle_coeff=angle_coeff_new,
                        dihedral_coeff=dihedral_coeff_new,
                        improper_coeff=improper_coeff_new,
                        atom_info=atom_info_new,
                        bond_info=bond_info_new,
                        angle_info=angle_info_new,
                        dihedral_info=dihedral_info_new,
                        improper_info=impropers_info_new)
    mapping_dict = {'mapping_bonds': mapping_bonds,
                    'mapping_angles': mapping_angles,
                    'mapping_dihedrals': mapping_dihedrals,
                    'mapping_impropers': mapping_impropers,
                    'mass_new': mass_new,
                    'unique_type': unique_type,
                    'pair_coeff_new': pair_coeff_new,
                    'bond_coeff_new': bond_coeff_new,
                    'angle_coeff_new': angle_coeff_new,
                    'dihedral_coeff_new': dihedral_coeff_new,
                    'improper_coeff_new': improper_coeff_new}
    return lmp_new, mapping_dict

def convert_lmp(file_lmp,file_key,mapping_dict):

    lmp_react1 = read_lammps_full(file_lmp)
    tmp = pd.read_table(file_key,
             header=None,sep='\s+',skiprows=31,nrows=lmp_react1.natoms)
    
    mapping = np.zeros([lmp_react1.natoms,2])
    mapping[:,0] = np.arange(lmp_react1.natoms)+1
    # modify the types given by Ligpargen

    for i, type in enumerate(mapping_dict['unique_type']):
        mapping[tmp.iloc[:,3]==type,1] = i+1

    # natom_types_new = len(mapping_dict['mass_new'])
    atom_info_new = lmp_react1.atom_info.copy()
    atom_info_new[:,2]=mapping[:,1]

    ### bonds ####
    bond_info_new = lmp_react1.bond_info.copy()
    for i in range(lmp_react1.natoms):
        bond_info_new[lmp_react1.bond_info[:,2]==i+1,2]=mapping[i,1]
        bond_info_new[lmp_react1.bond_info[:,3]==i+1,3]=mapping[i,1]

    for i in range(len(bond_info_new)):
        if bond_info_new[i,2]>bond_info_new[i,3]:
            tmp = bond_info_new[i,3]
            bond_info_new[i,3] = bond_info_new[i,2]
            bond_info_new[i,2] = tmp
        
    for i in range(len(bond_info_new)):
        bond_info_new[i,1]=0
        for j in range(len(mapping_dict['mapping_bonds'])):
            if ((bond_info_new[i,2]==mapping_dict['mapping_bonds'][j,0]) and (bond_info_new[i,3]==mapping_dict['mapping_bonds'][j,1])):
                bond_info_new[i,2]=lmp_react1.bond_info[i,2]
                bond_info_new[i,3]=lmp_react1.bond_info[i,3]
                bond_info_new[i,1]=j+1
    print(np.sum(bond_info_new[:,1]==0))

    # nangle_types_new = len(mapping_dict['angle_coeff_new'])
    ### angles ####
    angle_info_new = lmp_react1.angle_info.copy()
    for i in range(lmp_react1.natoms):
        angle_info_new[lmp_react1.angle_info[:,2]==i+1,2]=mapping[i,1]
        angle_info_new[lmp_react1.angle_info[:,3]==i+1,3]=mapping[i,1]
        angle_info_new[lmp_react1.angle_info[:,4]==i+1,4]=mapping[i,1]

    for i in range(len(angle_info_new)):
        if angle_info_new[i,2]>angle_info_new[i,4]:
            tmp = angle_info_new[i,4]
            angle_info_new[i,4] = angle_info_new[i,2]
            angle_info_new[i,2] = tmp 
        
    for i in range(len(angle_info_new)):
        angle_info_new[i,1]=0
        for j in range(len(mapping_dict['mapping_angles'])):
            if (angle_info_new[i,3]==mapping_dict['mapping_angles'][j,1]) and \
            ((angle_info_new[i,2]==mapping_dict['mapping_angles'][j,0]) and (angle_info_new[i,4]==mapping_dict['mapping_angles'][j,2])):
                angle_info_new[i,2]=lmp_react1.angle_info[i,2]
                angle_info_new[i,3]=lmp_react1.angle_info[i,3]
                angle_info_new[i,4]=lmp_react1.angle_info[i,4]
                angle_info_new[i,1]=j+1
    print(np.sum(angle_info_new[:,1]==0))
    ### dihedrals ####
    dihedral_info_new = lmp_react1.dihedral_info.copy()
    for i in range(lmp_react1.natoms):
        dihedral_info_new[lmp_react1.dihedral_info[:,2]==i+1,2]=mapping[i,1]
        dihedral_info_new[lmp_react1.dihedral_info[:,3]==i+1,3]=mapping[i,1]
        dihedral_info_new[lmp_react1.dihedral_info[:,4]==i+1,4]=mapping[i,1]
        dihedral_info_new[lmp_react1.dihedral_info[:,5]==i+1,5]=mapping[i,1]

    for i in range(len(dihedral_info_new)):
        dihedral_info_new[i,1]=0
        match = 0
        for j in range(len(mapping_dict['mapping_dihedrals'])):
            if ((dihedral_info_new[i,2]==mapping_dict['mapping_dihedrals'][j,0]) and (dihedral_info_new[i,3]==mapping_dict['mapping_dihedrals'][j,1])\
                and (dihedral_info_new[i,4]==mapping_dict['mapping_dihedrals'][j,2]) and (dihedral_info_new[i,5]==mapping_dict['mapping_dihedrals'][j,3])) or \
                ((dihedral_info_new[i,2]==mapping_dict['mapping_dihedrals'][j,3]) and (dihedral_info_new[i,3]==mapping_dict['mapping_dihedrals'][j,2])\
                and (dihedral_info_new[i,4]==mapping_dict['mapping_dihedrals'][j,1]) and (dihedral_info_new[i,5]==mapping_dict['mapping_dihedrals'][j,0])):
                dihedral_info_new[i,2]=lmp_react1.dihedral_info[i,2]
                dihedral_info_new[i,3]=lmp_react1.dihedral_info[i,3]
                dihedral_info_new[i,4]=lmp_react1.dihedral_info[i,4]
                dihedral_info_new[i,5]=lmp_react1.dihedral_info[i,5]
                dihedral_info_new[i,1]=j+1
                match+=1
        if match==0:
            dihedral_info_new[i,2]=lmp_react1.dihedral_info[i,2]
            dihedral_info_new[i,3]=lmp_react1.dihedral_info[i,3]
            dihedral_info_new[i,4]=lmp_react1.dihedral_info[i,4]
            dihedral_info_new[i,5]=lmp_react1.dihedral_info[i,5]
            dihedral_info_new[i,1]=mapping_dict['dihedral_coeff_new'][np.sum(mapping_dict['dihedral_coeff_new'][:,1:],axis=1)==0,0][0]
            print(dihedral_info_new[i])

    dihedral_info_new = np.delete(dihedral_info_new,np.squeeze(np.argwhere(dihedral_info_new[:,1]==0)),0)
    ndihedrals=len(dihedral_info_new)
    dihedral_info_new[:,0] = np.arange(1,ndihedrals+1)

    print(np.sum(dihedral_info_new[:,1]==0))


    nimproper_types_new = len(mapping_dict['improper_coeff_new'])
    ### impropers ####
    impropers_info_new = lmp_react1.improper_info.copy()
    for i in range(lmp_react1.natoms):
        impropers_info_new[lmp_react1.improper_info[:,2]==i+1,2]=mapping[i,1]
        impropers_info_new[lmp_react1.improper_info[:,3]==i+1,3]=mapping[i,1]
        impropers_info_new[lmp_react1.improper_info[:,4]==i+1,4]=mapping[i,1]
        impropers_info_new[lmp_react1.improper_info[:,5]==i+1,5]=mapping[i,1]

    for i in range(len(impropers_info_new)):
        impropers_info_new[i,1]=0
        match = 0
        for j in range(len(mapping_dict['mapping_impropers'])):
            if (impropers_info_new[i,2]==mapping_dict['mapping_impropers'][j,0]) and \
            np.all(np.sort(impropers_info_new[i,3:])==np.sort(mapping_dict['mapping_impropers'][j,1:])):
                impropers_info_new[i,2]=lmp_react1.improper_info[i,2]
                impropers_info_new[i,3]=lmp_react1.improper_info[i,3]
                impropers_info_new[i,4]=lmp_react1.improper_info[i,4]
                impropers_info_new[i,5]=lmp_react1.improper_info[i,5]
                impropers_info_new[i,1]=j+1
                match+=1
        if match==0:
            impropers_info_new[i,2]=lmp_react1.improper_info[i,2]
            impropers_info_new[i,3]=lmp_react1.improper_info[i,3]
            impropers_info_new[i,4]=lmp_react1.improper_info[i,4]
            impropers_info_new[i,5]=lmp_react1.improper_info[i,5]
            impropers_info_new[i,1]=mapping_dict['improper_coeff_new'][mapping_dict['improper_coeff_new'][:,1]==0,0][0]
            print(impropers_info_new[i])

    print(np.sum(impropers_info_new[:,1]==0))

    lmp_react_new = lammps(natoms=lmp_react1.natoms,
                    natom_types=len(mapping_dict['mass_new']),
                    nbonds=lmp_react1.nbonds,
                    nbond_types=len(mapping_dict['bond_coeff_new']),
                    nangles=lmp_react1.nangles,
                    nangle_types=len(mapping_dict['angle_coeff_new']),
                    ndihedrals=lmp_react1.ndihedrals,
                    ndihedral_types=len(mapping_dict['dihedral_coeff_new']),
                    nimpropers=lmp_react1.nimpropers,
                    nimproper_types=len(mapping_dict['improper_coeff_new']),
                    mass=mapping_dict['mass_new'],
                    x=lmp_react1.x,
                    y=lmp_react1.y,
                    z=lmp_react1.z,
                    pair_coeff=mapping_dict['pair_coeff_new'],
                    bond_coeff=mapping_dict['bond_coeff_new'],
                    angle_coeff=mapping_dict['angle_coeff_new'],
                    dihedral_coeff=mapping_dict['dihedral_coeff_new'],
                    improper_coeff=mapping_dict['improper_coeff_new'],
                    atom_info=atom_info_new,
                    bond_info=bond_info_new,
                    angle_info=angle_info_new,
                    dihedral_info=dihedral_info_new,
                    improper_info=impropers_info_new)
    return lmp_react_new

def write_template(file_lmp,file_template,idx_select,mapping_dict):

    lmp = read_lammps_full(file_lmp)

    natoms_select = len(idx_select)

    mapping = np.zeros([natoms_select,2])
    mapping[:,0] = idx_select
    mapping[:,1] = np.arange(1,natoms_select+1)

    # natom_types
    atom_type_select = np.empty([natoms_select,2])
    atom_type_select[:,0] = np.arange(1,natoms_select+1)
    atom_type_select[:,1] = lmp.atom_info[np.argsort(lmp.atom_info[:,0]),2][idx_select-1]

    charge_select = np.empty([natoms_select,2])
    charge_select[:,0] = np.arange(1,natoms_select+1)
    charge_select[:,1] = lmp.atom_info[np.argsort(lmp.atom_info[:,0]),3][idx_select-1]

    coors_select = np.empty([natoms_select,4])
    coors_select[:,0] = np.arange(1,natoms_select+1)
    coors_select[:,1:] = lmp.atom_info[np.argsort(lmp.atom_info[:,0]),4:7][idx_select-1]

    bond_info_new = []
    j=0
    for i in range(len(lmp.bond_info)):
        if (lmp.bond_info[i,2] in idx_select) and (lmp.bond_info[i,3] in idx_select):
            j+=1
            bond_info_new.append([j,lmp.bond_info[i,1],mapping[mapping[:,0]==lmp.bond_info[i,2],1][0],mapping[mapping[:,0]==lmp.bond_info[i,3],1][0]])
    bond_info_new = np.vstack(bond_info_new)

    nbond_type_new = len(mapping_dict['bond_coeff_new'])
    nbonds_select = len(bond_info_new)

    # angles 
    angle_info_new = []
    j=0
    for i in range(len(lmp.angle_info)):
        if (lmp.angle_info[i,2] in idx_select) and (lmp.angle_info[i,3] in idx_select) and (lmp.angle_info[i,4] in idx_select):
            j+=1
            angle_info_new.append([j,lmp.angle_info[i,1],mapping[mapping[:,0]==lmp.angle_info[i,2],1][0],mapping[mapping[:,0]==lmp.angle_info[i,3],1][0],
                                mapping[mapping[:,0]==lmp.angle_info[i,4],1][0]])
    angle_info_new = np.vstack(angle_info_new)

    nangle_type_new = len(mapping_dict['angle_coeff_new'])
    nangles_select = len(angle_info_new)

    # dihedrals
    dihedral_info_new = []

    j=0
    for i in range(len(lmp.dihedral_info)):
        if (lmp.dihedral_info[i,2] in idx_select) and (lmp.dihedral_info[i,3] in idx_select) and (lmp.dihedral_info[i,4] in idx_select)\
        and (lmp.dihedral_info[i,5] in idx_select):
            j+=1
            dihedral_info_new.append([j,lmp.dihedral_info[i,1],mapping[mapping[:,0]==lmp.dihedral_info[i,2],1][0],mapping[mapping[:,0]==lmp.dihedral_info[i,3],1][0],
                                mapping[mapping[:,0]==lmp.dihedral_info[i,4],1][0],mapping[mapping[:,0]==lmp.dihedral_info[i,5],1][0]])
            
    dihedral_info_new = np.vstack(dihedral_info_new)

    ndihedral_type_new = len(mapping_dict['dihedral_coeff_new'])
    ndihedrals_select = len(dihedral_info_new)

    # impropers
    impropers_info_new = []

    j=0
    for i in range(len(lmp.improper_info)):
        if (lmp.improper_info[i,2] in idx_select) and (lmp.improper_info[i,3] in idx_select) and (lmp.improper_info[i,4] in idx_select)\
        and (lmp.improper_info[i,5] in idx_select):
            j+=1
            impropers_info_new.append([j,lmp.improper_info[i,1],mapping[mapping[:,0]==lmp.improper_info[i,2],1][0],mapping[mapping[:,0]==lmp.improper_info[i,3],1][0],
                                mapping[mapping[:,0]==lmp.improper_info[i,4],1][0],mapping[mapping[:,0]==lmp.improper_info[i,5],1][0]])
            
    impropers_info_new = np.vstack(impropers_info_new)
    nimproper_type_new = len(mapping_dict['improper_coeff_new'])
    nimpropers_select = len(impropers_info_new)

    # file_template = './rxn2_post_v2.data_template'
    f=open('{}'.format(file_template),'w')
    f.write('rxn2_post\n\n')
    f.write('{} atoms\n'.format(natoms_select))
    f.write('{} bonds\n'.format(nbonds_select))
    f.write('{} angles\n'.format(nangles_select))
    f.write('{} dihedrals\n'.format(ndihedrals_select))
    f.write('{} impropers\n'.format(nimpropers_select))
    f.write('\n')

    f.write('Types\n')
    f.write('\n')
    for i in range(len(atom_type_select)):
        f.write('{:.0f} {:.0f}\n'.format(atom_type_select[i,0],atom_type_select[i,1]))
    f.write('\n') 

    f.write('Charges\n')
    f.write('\n')
    for i in range(len(charge_select)):
        f.write('{:.0f} {}\n'.format(charge_select[i,0],charge_select[i,1]))
    f.write('\n')

    f.write('Coords\n')
    f.write('\n')
    for i in range(natoms_select):
        f.write('{:.0f} {} {} {}\n'.format(coors_select[i,0],coors_select[i,1],coors_select[i,2],coors_select[i,3]))
    f.write('\n')

    f.write('Bonds\n')
    f.write('\n')
    for i in range(len(bond_info_new)):
        f.write('{:.0f} {:.0f} {:.0f} {:.0f}\n'.format(int(bond_info_new[i,0]),int(bond_info_new[i,1]),\
                                        int(bond_info_new[i,2]),int(bond_info_new[i,3])))
    f.write('\n')

    f.write('Angles\n')
    f.write('\n')
    for i in range(len(angle_info_new)):
        f.write('{:.0f} {:.0f} {:.0f} {:.0f} {:.0f}\n'.format(angle_info_new[i,0],angle_info_new[i,1],\
                                        angle_info_new[i,2],angle_info_new[i,3],\
                                        angle_info_new[i,4]))
    f.write('\n')

    f.write('Dihedrals\n')
    f.write('\n')
    for i in range(len(dihedral_info_new)):
        f.write('{:.0f} {:.0f} {:.0f} {:.0f} {:.0f} {:.0f}\n'.format(dihedral_info_new[i,0],dihedral_info_new[i,1],\
                                        dihedral_info_new[i,2],dihedral_info_new[i,3],\
                                        dihedral_info_new[i,4],dihedral_info_new[i,5]))
    f.write('\n')

    f.write('Impropers\n')
    f.write('\n')
    for i in range(len(impropers_info_new)):
        f.write('{:.0f} {:.0f} {:.0f} {:.0f} {:.0f} {:.0f}\n'.format(impropers_info_new[i,0],impropers_info_new[i,1],\
                                        impropers_info_new[i,2],impropers_info_new[i,3],\
                                        impropers_info_new[i,4],impropers_info_new[i,5]))
    f.write('\n')
    f.close()

def visualize_template(file_template,file_visual,element):

    f=open(file_template,'r')
    L=f.readlines()
    f.close()

    for iline in range(len(L)):
        if 'atoms' in L[iline]:
            natoms = int(L[iline].split()[0])
        if 'bonds' in L[iline]:
            nbonds = int(L[iline].split()[0])
        if 'angles' in L[iline]:
            nangles = int(L[iline].split()[0])
        if 'dihedrals' in L[iline]:
            ndihedrals = int(L[iline].split()[0])
        if 'impropers' in L[iline]:
            nimpropers = int(L[iline].split()[0])
        if 'Types' in L[iline]:
            ltype = iline+2
            atom_type = np.empty(natoms)
            for ia in range(natoms):
                atom_type[ia] = int(L[ltype+ia].split()[1])

        if 'Coords' in L[iline]:
            lia = iline+2

        if 'Bonds' in L[iline]:
            lib = iline+2

    atom_info = pd.read_table(file_template,header=None,sep='\s+',skiprows=lia-1,nrows=natoms)

    box = np.eye(3)*40
    write_lammps_simple(file_visual,
                box,int(np.max(atom_type)),natoms,np.zeros(int(np.max(atom_type))),element,
                np.zeros(int(np.max(atom_type))),np.array(atom_info.iloc[:,0]),
                atom_type,np.array(atom_info.iloc[:,1:])-np.array([np.min(atom_info.iloc[:,1:],axis=0)]))